.sort #отсортировать в алфавитном порядке
.size/length #получить количество элементов
.each #Сделать итерацию по каждому элементу
.each_char #для строк, пройтись по каждой букве
.chomp #удалить разрыв строки (\n)
.empty? #Проверяет пуст ли массив или что-то иное
.count #Без аргументов возвращает количество элементов массива. Если задан аргумент, считает количество элементов которые равны obj через ==. Если передан блок, считает количество элементов для которых блок возвращает true.
3.respond_to? 'puts' #false, Возможность выяснить, можно ли вызывать в отношении того или иного объетка метод
p range.include? 3 #Проверка вхождения в диапазон
p (1..).include? -1
p range.cover?(1..3) #Может сравнивать ряды
arr.sample(2) # выбирает рандомные элементы массива, через аргумент можно выбрать количество
arr.send(m) #способ вызвать метод "m" для "arr"
14.64.round # округление числа
(1..7).cover? 1..3 # сравнение диапазонов (include?)
.join(" ") - делает из массива строку, в аргументе строка-разделитель
strip #убирает пробелы по боком в строке
.split(" ") #конвертирует подстроки строки в массив, по умолчанию разделителем выступает пустая строка
.push and unshift # добавление элементов массива в конец и начало
.insert(0, 2, 3) #вставляет элемент в определенное место массива, первый аргумент - место, последующие - элементы
.slice #сделать подмассив из существующего массива
.values_at(1, 2, 3) #извлечь элементы по индексам
.take(3) #берет из начала указанное количество элементов
.drop(3) #берет из конца
.take_while and .drop_while #принимают блок с условием
.index('red') #будет искать индекс по значению с начала массива
.rindex #с конца
.shuffle #возвращает новый массив с перемешанными значениями
.pop .shift #удаление из конца и начала массива эл-ов, если указан аргумент, возвращает массив
.delete #удаляет эл-ы по значению
.delete_at #удаление по индексу
.clear #удалить все элементы массива
.compact #удалить все nil значения
.uniq! #преобразует исходный массив где удалены все дублирующие элементы
.fill #заполняет все nil аргументом или блоком
.replace #заменяет один массив другом arr.replace []
[] | [] #возвращает уникальные элементы || [].union []
[] & [] #только одинаковые элементы
[].all? #проверяет что все элементы === true, в блоке можно задать логику сравниванияц
[].any? #какой-то элемент true
.one? #проверяет лишь один элемент true
.none? #если элемента нет - true, если все false or nil - true 
				Хэши
.fetch(:first, 0) #обращается к значению по ключю, если указан второй аргумент, выводит его, если данного ключа не существует, поддерживает блок, где переменная - ключ
.dig(:seo, :keywords) #действует для многомерного массива, если ключа нет - возвращает nil
.key(value) #возвращает ключ по значению, первый слева направо
.default = 2 #установка вместо nil другое значение
Hash.new(2) то же  самое что сверху
.slice(:first) #возвращает хэш с парой ключ-значение, ключ которых указан в аргументе
.clear #очищение всего массива
.shift #удаление из начала пары ключ-значение
.delete #удалить по ключу, принимает блок, где указывается, что возвращать если ключ не найден
.delete_if {k, v} #удаляет по условию
.count {v, k} #посчитать кол-во по уловию
.key? and .value? #проверить наличие элемента
a.merge b #сложить хеши



Итератор For: next - для пропуска итерации, redo - для повторной итерации, retry - заставляет весь цикл работать еще раз по-новой

hash.delete(key) удаляет пару ключ-значение из хэша по ключу;
hash.key(value) возвращает ключ для заданного значения в хэше, или nil, если соответствующее значение не найдено;
hash.invert создает новый хэш, делая реверс ключей и значений из хэша; т.е. в новом хэше ключи из хэша становятся значениями, а значения - ключами;
hash.keys возвращает новый массив с ключами из хэша;
hash.values возвращает новый массив, содержащий все значения хэша;
hash.length возвращает длину хэша в виде целого числа.



























module Mymodule
	initlize .
end

Подключить модуль к классу
class Dog
include Mymodule
другое методы
end
